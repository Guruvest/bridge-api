// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"net/http"
	"strings"

	errors "github.com/go-openapi/errors"
	loads "github.com/go-openapi/loads"
	runtime "github.com/go-openapi/runtime"
	middleware "github.com/go-openapi/runtime/middleware"
	security "github.com/go-openapi/runtime/security"
	spec "github.com/go-openapi/spec"
	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"

	"github.com/Guruvest/bridge-api/restapi/operations/account_data"
	"github.com/Guruvest/bridge-api/restapi/operations/market_access"
	"github.com/Guruvest/bridge-api/restapi/operations/system_info"
)

// NewBridgeapiAPI creates a new Bridgeapi instance
func NewBridgeapiAPI(spec *loads.Document) *BridgeapiAPI {
	return &BridgeapiAPI{
		handlers:            make(map[string]map[string]http.Handler),
		formats:             strfmt.Default,
		defaultConsumes:     "application/json",
		defaultProduces:     "application/json",
		ServerShutdown:      func() {},
		spec:                spec,
		ServeError:          errors.ServeError,
		BasicAuthenticator:  security.BasicAuth,
		APIKeyAuthenticator: security.APIKeyAuth,
		BearerAuthenticator: security.BearerAuth,
		JSONConsumer:        runtime.JSONConsumer(),
		JSONProducer:        runtime.JSONProducer(),
		SystemInfoSystemInfoHandler: system_info.SystemInfoHandlerFunc(func(params system_info.SystemInfoParams) middleware.Responder {
			return middleware.NotImplemented("operation SystemInfoSystemInfo has not yet been implemented")
		}),
		MarketAccessAddOrderHandler: market_access.AddOrderHandlerFunc(func(params market_access.AddOrderParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation MarketAccessAddOrder has not yet been implemented")
		}),
		MarketAccessCancelOrderHandler: market_access.CancelOrderHandlerFunc(func(params market_access.CancelOrderParams) middleware.Responder {
			return middleware.NotImplemented("operation MarketAccessCancelOrder has not yet been implemented")
		}),
		MarketAccessGetExchangesHandler: market_access.GetExchangesHandlerFunc(func(params market_access.GetExchangesParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation MarketAccessGetExchanges has not yet been implemented")
		}),
		AccountDataGetLinkedAccountsHandler: account_data.GetLinkedAccountsHandlerFunc(func(params account_data.GetLinkedAccountsParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation AccountDataGetLinkedAccounts has not yet been implemented")
		}),
		MarketAccessGetOrderByIDHandler: market_access.GetOrderByIDHandlerFunc(func(params market_access.GetOrderByIDParams) middleware.Responder {
			return middleware.NotImplemented("operation MarketAccessGetOrderByID has not yet been implemented")
		}),
		AccountDataGetOrdersByAccountHandler: account_data.GetOrdersByAccountHandlerFunc(func(params account_data.GetOrdersByAccountParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation AccountDataGetOrdersByAccount has not yet been implemented")
		}),
		AccountDataGetPortfoliosByAccountHandler: account_data.GetPortfoliosByAccountHandlerFunc(func(params account_data.GetPortfoliosByAccountParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation AccountDataGetPortfoliosByAccount has not yet been implemented")
		}),
		MarketAccessGetSymbolsHandler: market_access.GetSymbolsHandlerFunc(func(params market_access.GetSymbolsParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation MarketAccessGetSymbols has not yet been implemented")
		}),
		MarketAccessGetTickerHandler: market_access.GetTickerHandlerFunc(func(params market_access.GetTickerParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation MarketAccessGetTicker has not yet been implemented")
		}),
		AccountDataGetTradesByAccountHandler: account_data.GetTradesByAccountHandlerFunc(func(params account_data.GetTradesByAccountParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation AccountDataGetTradesByAccount has not yet been implemented")
		}),
		MarketAccessUpdateOrderHandler: market_access.UpdateOrderHandlerFunc(func(params market_access.UpdateOrderParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation MarketAccessUpdateOrder has not yet been implemented")
		}),

		BridgeAuthAuth: func(token string, scopes []string) (interface{}, error) {
			return nil, errors.NotImplemented("oauth2 bearer auth (bridge_auth) has not yet been implemented")
		},

		// default authorizer is authorized meaning no requests are blocked
		APIAuthorizer: security.Authorized(),
	}
}

/*BridgeapiAPI The Guruvest Bridge API is a REST API served the Guruvest platform. It is the API that third party client uses to communicate signals to the Guruvest platform.

# Errors

The API uses standard HTTP status codes to indicate the success or failure of the API call. The body of the response will be JSON in the following format:

```
{
  "message": "page not found"
}
```

# Versioning

The API is usually changed in each release, so API calls are versioned to
ensure that clients don't break. To lock to a specific version of the API,
you prefix the URL with its version, for example, call `/v0/info` to use
the v0 version of the `/info` endpoint. If the API version specified in
the URL is not supported by the daemon, a HTTP `400 Bad Request` error message
is returned.

If you omit the version-prefix, the current version of the API (v1) is used.
For example, calling `/info` is the same as calling `/v1/info`. Using the
API without a version-prefix is deprecated and will be removed in a future release.

The API uses an open schema model, which means server may add extra properties
to responses. Likewise, the server will ignore any extra query parameters and
request body properties. When you write clients, you need to ignore additional
properties in responses to ensure they do not break when talking to newer
daemons.


```
*/
type BridgeapiAPI struct {
	spec            *loads.Document
	context         *middleware.Context
	handlers        map[string]map[string]http.Handler
	formats         strfmt.Registry
	defaultConsumes string
	defaultProduces string
	Middleware      func(middleware.Builder) http.Handler

	// BasicAuthenticator generates a runtime.Authenticator from the supplied basic auth function.
	// It has a default implemention in the security package, however you can replace it for your particular usage.
	BasicAuthenticator func(security.UserPassAuthentication) runtime.Authenticator
	// APIKeyAuthenticator generates a runtime.Authenticator from the supplied token auth function.
	// It has a default implemention in the security package, however you can replace it for your particular usage.
	APIKeyAuthenticator func(string, string, security.TokenAuthentication) runtime.Authenticator
	// BearerAuthenticator generates a runtime.Authenticator from the supplied bearer token auth function.
	// It has a default implemention in the security package, however you can replace it for your particular usage.
	BearerAuthenticator func(string, security.ScopedTokenAuthentication) runtime.Authenticator

	// JSONConsumer registers a consumer for a "application/json" mime type
	JSONConsumer runtime.Consumer

	// JSONProducer registers a producer for a "application/json" mime type
	JSONProducer runtime.Producer

	// BridgeAuthAuth registers a function that takes an access token and a collection of required scopes and returns a principal
	// it performs authentication based on an oauth2 bearer token provided in the request
	BridgeAuthAuth func(string, []string) (interface{}, error)

	// APIAuthorizer provides access control (ACL/RBAC/ABAC) by providing access to the request and authenticated principal
	APIAuthorizer runtime.Authorizer

	// SystemInfoSystemInfoHandler sets the operation handler for the system info operation
	SystemInfoSystemInfoHandler system_info.SystemInfoHandler
	// MarketAccessAddOrderHandler sets the operation handler for the add order operation
	MarketAccessAddOrderHandler market_access.AddOrderHandler
	// MarketAccessCancelOrderHandler sets the operation handler for the cancel order operation
	MarketAccessCancelOrderHandler market_access.CancelOrderHandler
	// MarketAccessGetExchangesHandler sets the operation handler for the get exchanges operation
	MarketAccessGetExchangesHandler market_access.GetExchangesHandler
	// AccountDataGetLinkedAccountsHandler sets the operation handler for the get linked accounts operation
	AccountDataGetLinkedAccountsHandler account_data.GetLinkedAccountsHandler
	// MarketAccessGetOrderByIDHandler sets the operation handler for the get order by Id operation
	MarketAccessGetOrderByIDHandler market_access.GetOrderByIDHandler
	// AccountDataGetOrdersByAccountHandler sets the operation handler for the get orders by account operation
	AccountDataGetOrdersByAccountHandler account_data.GetOrdersByAccountHandler
	// AccountDataGetPortfoliosByAccountHandler sets the operation handler for the get portfolios by account operation
	AccountDataGetPortfoliosByAccountHandler account_data.GetPortfoliosByAccountHandler
	// MarketAccessGetSymbolsHandler sets the operation handler for the get symbols operation
	MarketAccessGetSymbolsHandler market_access.GetSymbolsHandler
	// MarketAccessGetTickerHandler sets the operation handler for the get ticker operation
	MarketAccessGetTickerHandler market_access.GetTickerHandler
	// AccountDataGetTradesByAccountHandler sets the operation handler for the get trades by account operation
	AccountDataGetTradesByAccountHandler account_data.GetTradesByAccountHandler
	// MarketAccessUpdateOrderHandler sets the operation handler for the update order operation
	MarketAccessUpdateOrderHandler market_access.UpdateOrderHandler

	// ServeError is called when an error is received, there is a default handler
	// but you can set your own with this
	ServeError func(http.ResponseWriter, *http.Request, error)

	// ServerShutdown is called when the HTTP(S) server is shut down and done
	// handling all active connections and does not accept connections any more
	ServerShutdown func()

	// Custom command line argument groups with their descriptions
	CommandLineOptionsGroups []swag.CommandLineOptionsGroup

	// User defined logger function.
	Logger func(string, ...interface{})
}

// SetDefaultProduces sets the default produces media type
func (o *BridgeapiAPI) SetDefaultProduces(mediaType string) {
	o.defaultProduces = mediaType
}

// SetDefaultConsumes returns the default consumes media type
func (o *BridgeapiAPI) SetDefaultConsumes(mediaType string) {
	o.defaultConsumes = mediaType
}

// SetSpec sets a spec that will be served for the clients.
func (o *BridgeapiAPI) SetSpec(spec *loads.Document) {
	o.spec = spec
}

// DefaultProduces returns the default produces media type
func (o *BridgeapiAPI) DefaultProduces() string {
	return o.defaultProduces
}

// DefaultConsumes returns the default consumes media type
func (o *BridgeapiAPI) DefaultConsumes() string {
	return o.defaultConsumes
}

// Formats returns the registered string formats
func (o *BridgeapiAPI) Formats() strfmt.Registry {
	return o.formats
}

// RegisterFormat registers a custom format validator
func (o *BridgeapiAPI) RegisterFormat(name string, format strfmt.Format, validator strfmt.Validator) {
	o.formats.Add(name, format, validator)
}

// Validate validates the registrations in the BridgeapiAPI
func (o *BridgeapiAPI) Validate() error {
	var unregistered []string

	if o.JSONConsumer == nil {
		unregistered = append(unregistered, "JSONConsumer")
	}

	if o.JSONProducer == nil {
		unregistered = append(unregistered, "JSONProducer")
	}

	if o.BridgeAuthAuth == nil {
		unregistered = append(unregistered, "BridgeAuthAuth")
	}

	if o.SystemInfoSystemInfoHandler == nil {
		unregistered = append(unregistered, "system_info.SystemInfoHandler")
	}

	if o.MarketAccessAddOrderHandler == nil {
		unregistered = append(unregistered, "market_access.AddOrderHandler")
	}

	if o.MarketAccessCancelOrderHandler == nil {
		unregistered = append(unregistered, "market_access.CancelOrderHandler")
	}

	if o.MarketAccessGetExchangesHandler == nil {
		unregistered = append(unregistered, "market_access.GetExchangesHandler")
	}

	if o.AccountDataGetLinkedAccountsHandler == nil {
		unregistered = append(unregistered, "account_data.GetLinkedAccountsHandler")
	}

	if o.MarketAccessGetOrderByIDHandler == nil {
		unregistered = append(unregistered, "market_access.GetOrderByIDHandler")
	}

	if o.AccountDataGetOrdersByAccountHandler == nil {
		unregistered = append(unregistered, "account_data.GetOrdersByAccountHandler")
	}

	if o.AccountDataGetPortfoliosByAccountHandler == nil {
		unregistered = append(unregistered, "account_data.GetPortfoliosByAccountHandler")
	}

	if o.MarketAccessGetSymbolsHandler == nil {
		unregistered = append(unregistered, "market_access.GetSymbolsHandler")
	}

	if o.MarketAccessGetTickerHandler == nil {
		unregistered = append(unregistered, "market_access.GetTickerHandler")
	}

	if o.AccountDataGetTradesByAccountHandler == nil {
		unregistered = append(unregistered, "account_data.GetTradesByAccountHandler")
	}

	if o.MarketAccessUpdateOrderHandler == nil {
		unregistered = append(unregistered, "market_access.UpdateOrderHandler")
	}

	if len(unregistered) > 0 {
		return fmt.Errorf("missing registration: %s", strings.Join(unregistered, ", "))
	}

	return nil
}

// ServeErrorFor gets a error handler for a given operation id
func (o *BridgeapiAPI) ServeErrorFor(operationID string) func(http.ResponseWriter, *http.Request, error) {
	return o.ServeError
}

// AuthenticatorsFor gets the authenticators for the specified security schemes
func (o *BridgeapiAPI) AuthenticatorsFor(schemes map[string]spec.SecurityScheme) map[string]runtime.Authenticator {

	result := make(map[string]runtime.Authenticator)
	for name, scheme := range schemes {
		switch name {

		case "bridge_auth":

			result[name] = o.BearerAuthenticator(scheme.Name, o.BridgeAuthAuth)

		}
	}
	return result

}

// Authorizer returns the registered authorizer
func (o *BridgeapiAPI) Authorizer() runtime.Authorizer {

	return o.APIAuthorizer

}

// ConsumersFor gets the consumers for the specified media types
func (o *BridgeapiAPI) ConsumersFor(mediaTypes []string) map[string]runtime.Consumer {

	result := make(map[string]runtime.Consumer)
	for _, mt := range mediaTypes {
		switch mt {

		case "application/json":
			result["application/json"] = o.JSONConsumer

		}
	}
	return result

}

// ProducersFor gets the producers for the specified media types
func (o *BridgeapiAPI) ProducersFor(mediaTypes []string) map[string]runtime.Producer {

	result := make(map[string]runtime.Producer)
	for _, mt := range mediaTypes {
		switch mt {

		case "application/json":
			result["application/json"] = o.JSONProducer

		}
	}
	return result

}

// HandlerFor gets a http.Handler for the provided operation method and path
func (o *BridgeapiAPI) HandlerFor(method, path string) (http.Handler, bool) {
	if o.handlers == nil {
		return nil, false
	}
	um := strings.ToUpper(method)
	if _, ok := o.handlers[um]; !ok {
		return nil, false
	}
	if path == "/" {
		path = ""
	}
	h, ok := o.handlers[um][path]
	return h, ok
}

// Context returns the middleware context for the bridgeapi API
func (o *BridgeapiAPI) Context() *middleware.Context {
	if o.context == nil {
		o.context = middleware.NewRoutableContext(o.spec, o, nil)
	}

	return o.context
}

func (o *BridgeapiAPI) initHandlerCache() {
	o.Context() // don't care about the result, just that the initialization happened

	if o.handlers == nil {
		o.handlers = make(map[string]map[string]http.Handler)
	}

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/info"] = system_info.NewSystemInfo(o.context, o.SystemInfoSystemInfoHandler)

	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/market/orders"] = market_access.NewAddOrder(o.context, o.MarketAccessAddOrderHandler)

	if o.handlers["DELETE"] == nil {
		o.handlers["DELETE"] = make(map[string]http.Handler)
	}
	o.handlers["DELETE"]["/market/orders/{order_id}"] = market_access.NewCancelOrder(o.context, o.MarketAccessCancelOrderHandler)

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/market/exchanges"] = market_access.NewGetExchanges(o.context, o.MarketAccessGetExchangesHandler)

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/accounts"] = account_data.NewGetLinkedAccounts(o.context, o.AccountDataGetLinkedAccountsHandler)

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/market/orders/{order_id}"] = market_access.NewGetOrderByID(o.context, o.MarketAccessGetOrderByIDHandler)

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/accounts/orders"] = account_data.NewGetOrdersByAccount(o.context, o.AccountDataGetOrdersByAccountHandler)

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/accounts/portfolios"] = account_data.NewGetPortfoliosByAccount(o.context, o.AccountDataGetPortfoliosByAccountHandler)

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/market/symbols"] = market_access.NewGetSymbols(o.context, o.MarketAccessGetSymbolsHandler)

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/market/tickers"] = market_access.NewGetTicker(o.context, o.MarketAccessGetTickerHandler)

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/accounts/trades"] = account_data.NewGetTradesByAccount(o.context, o.AccountDataGetTradesByAccountHandler)

	if o.handlers["PUT"] == nil {
		o.handlers["PUT"] = make(map[string]http.Handler)
	}
	o.handlers["PUT"]["/market/orders/{order_id}"] = market_access.NewUpdateOrder(o.context, o.MarketAccessUpdateOrderHandler)

}

// Serve creates a http handler to serve the API over HTTP
// can be used directly in http.ListenAndServe(":8000", api.Serve(nil))
func (o *BridgeapiAPI) Serve(builder middleware.Builder) http.Handler {
	o.Init()

	if o.Middleware != nil {
		return o.Middleware(builder)
	}
	return o.context.APIHandler(builder)
}

// Init allows you to just initialize the handler cache, you can then recompose the middelware as you see fit
func (o *BridgeapiAPI) Init() {
	if len(o.handlers) == 0 {
		o.initHandlerCache()
	}
}
