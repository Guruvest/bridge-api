// Code generated by go-swagger; DO NOT EDIT.

package market_access

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the generate command

import (
	"net/http"

	middleware "github.com/go-openapi/runtime/middleware"
)

// GetTickerHandlerFunc turns a function with the right signature into a get ticker handler
type GetTickerHandlerFunc func(GetTickerParams, interface{}) middleware.Responder

// Handle executing the request and returning a response
func (fn GetTickerHandlerFunc) Handle(params GetTickerParams, principal interface{}) middleware.Responder {
	return fn(params, principal)
}

// GetTickerHandler interface for that can handle valid get ticker params
type GetTickerHandler interface {
	Handle(GetTickerParams, interface{}) middleware.Responder
}

// NewGetTicker creates a new http.Handler for the get ticker operation
func NewGetTicker(ctx *middleware.Context, handler GetTickerHandler) *GetTicker {
	return &GetTicker{Context: ctx, Handler: handler}
}

/*GetTicker swagger:route GET /market/tickers Market Access getTicker

Returns last, high (24h), low (24h), ask, bid for specified symbol

Return the last, high (24h), low (24h), ask, bid for specified symbol. If no trading venue (exchange_id) is specified, the default one will be used

*/
type GetTicker struct {
	Context *middleware.Context
	Handler GetTickerHandler
}

func (o *GetTicker) ServeHTTP(rw http.ResponseWriter, r *http.Request) {
	route, rCtx, _ := o.Context.RouteInfo(r)
	if rCtx != nil {
		r = rCtx
	}
	var Params = NewGetTickerParams()

	uprinc, aCtx, err := o.Context.Authorize(r, route)
	if err != nil {
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}
	if aCtx != nil {
		r = aCtx
	}
	var principal interface{}
	if uprinc != nil {
		principal = uprinc
	}

	if err := o.Context.BindValidRequest(r, route, &Params); err != nil { // bind params
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}

	res := o.Handler.Handle(Params, principal) // actually handle the request

	o.Context.Respond(rw, r, route.Produces, route, res)

}
